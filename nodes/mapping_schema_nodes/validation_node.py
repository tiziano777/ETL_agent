from states.mapping_schema_state import State
from typing import Dict, List, Literal, Union
from langgraph.types import Command

import json
from json_repair import repair_json
import traceback

from mappings.mapper import Mapper

class ValidationNode:
    """
    Node responsible for validating the mapping produced by an LLM.

    Responsibilities:
    -----------------
    1. Extracts and repairs JSON from LLM output.
    2. Ensures mappings follow the expected structure (list of mapping objects).
    3. Applies the mappings to the provided samples via Mapper.
    4. Validates transformed samples against the target schema.
    5. Returns a Command that decides the next step:
        - "writer_node" if mapping is valid
        - "llm_node" if mapping is invalid and needs regeneration
    """

    def __init__(self):
        """
        Initialize the validation node with a Mapper instance.
        The Mapper encapsulates the logic for applying mappings and schema validation.
        """
        self.mapper = Mapper()

    def _extract_json(self, json_text: str) -> Union[List[Dict], None]:
        """
        Repair and deserialize JSON generated by the LLM.

        Parameters
        ----------
        json_text : str
            The raw string output from the LLM that should contain a mapping definition.

        Returns
        -------
        Union[List[Dict], None]
            A list of mapping objects if successfully parsed, otherwise None.
        """
        try:
            # Step 1: Attempt to repair malformed JSON text
            repaired_text = repair_json(json_text)

            # Step 2: Parse into Python object
            parsed_json = json.loads(repaired_text)

            # Step 3: Handle expected list format
            if isinstance(parsed_json, list):
                return parsed_json
                

            # Step 5: Fallback warning
            print("Warning: LLM output is not in the expected mapping format.")
            return None

        except Exception as e:
            # Robust error handling
            print(f"Failed to parse/repair JSON: {e}")
            return None

    def __call__(self, state: State) -> Command[Literal["llm_node", "writer_node"]]:
        """
        Validate the mapping against provided samples and schema.
        Given a mapping M : S -> D where S is the src_schema and D is the dst_schema,
        the node applies M to each sample X in state.samples and checks if the output conforms to D.
        If M is valid for all samples, proceed to "writer_node", and store mapped sample for a final overview.
        If M is invalid for any sample, return to "llm_node" with feedback.

        Parameters
        ----------
        state : State
            The current pipeline state containing samples, schema, and LLM outputs.

        Returns
        -------
        Command
            A directive for the graph execution engine:
            - goto="writer_node" with mapping if validation passes
            - goto="llm_node" with feedback if validation fails
        """
        print("Validating mapping with samples...")
        state.error_messages = []  # Reset previous error log

        # --------------------------------------------------------
        # Phase 1: Extract mapping JSON from LLM output
        # --------------------------------------------------------
        try:
            mapping_str = state.chat_history[-1].content  # Last message from LLM
            generated_mapping = self._extract_json(mapping_str)

            print(generated_mapping)

            if not generated_mapping:
                # Case: invalid or unparsable mapping
                feedback_msg = (
                    "Output is not a valid JSON array for the mapping. "
                    "Please regenerate an array of mapping objects."
                )
                return Command(
                    goto="llm_node",
                    update={"valid": False, "feedback": feedback_msg, "mapping": None},
                )

        except Exception as e:
            # Catch any unexpected exception during JSON parsing
            feedback_msg = f"Error in processing LLM output: {str(e)}"
            print(traceback.format_exc())
            return Command(
                goto="llm_node",
                update={"valid": False, "feedback": feedback_msg, "mapping": None},
            )

        # --------------------------------------------------------
        # Phase 2: Validate mapping against target schema
        # --------------------------------------------------------
        try:
            target_schema = state.dst_schema
        except AttributeError:
            # If schema is missing, it's a configuration error
            print(traceback.format_exc())
            raise RuntimeError("dst_schema is missing from the state.")

        valid = True
        for i, sample in enumerate(state.samples):
            # Apply mapping and validate sample via Mapper
            transformed_sample, valid_mapping, errors = self.mapper.map_and_validate(
                sample, generated_mapping, target_schema
            )
            print(f"Sample {i+1} validation result: {valid_mapping}, Errors: {errors}, Transformed: {transformed_sample}")
            state.mapped_samples.append(transformed_sample)  # Store for overview

            if not valid_mapping:
                valid = False
                # Collect all error messages for feedback to the LLM
                state.error_messages.append(
                    f"Mapping validation failed for sample {i+1}:\nOutput: {transformed_sample}"
                )
                state.error_messages.extend(
                    [f"Sample {i+1}: {err}" for err in errors]
                )

        # --------------------------------------------------------
        # Phase 3: Return next command based on validation result
        # --------------------------------------------------------
        if valid:
            print("Mapping validated successfully!")
            return Command(
                goto="writer_node",
                update={
                    "mapping": generated_mapping,
                    "valid": True,
                    "mapped_samples": [
                        self.mapper.apply_mapping(sample, generated_mapping, target_schema)
                        for sample in state.samples
                    ],
                },
            )
        else:
            print("Invalid mapping. Validation errors:", state.error_messages)
            feedback_msg = "The mapping is invalid. Errors found:\n" + "\n".join(
                state.error_messages
            )
            return Command(
                goto="llm_node",
                update={
                    "valid": False,
                    "feedback": feedback_msg,
                    "mapping": generated_mapping,
                    "mapped_samples": [],
                },
            )
